(*
some labs opted to study the simpler grammar
exp ::= <exp> or <exp> | <exp> and <exp> | <val>
val ::= true | false
*)
(* some of the strings that this grammar can parse *)
"true or false";;
"true and false or true";;
"true or true and true";;
"true or false and false";;
"true or true or true or true or true or true or true or true";;
"true or false and true or true and false or true and true and false";;
"true or true or true and false or false and true and true";;
"true";;
"false";;

(* some strings that this grammar can't parse are *)
"(false)";;
"and true";;
"false or or true";;

(* the parse trees of a grammar can be modeled by data types *)
type val1 = True1 | False1
type exp1 = Or1 of (exp1 * exp1) | And1 of (exp1 * exp1) | Val1 of val1

(* these functions generate the string the parse tree represents *)
let val1_to_str v =
  match v with
    | True1 -> "true"
    | False1 -> "false"
	
let rec exp1_to_str t =
  match t with
    | Or1 (l,r) -> (exp1_to_str l) ^ " or " ^ (exp1_to_str r) 
    | And1 (l,r) -> (exp1_to_str l) ^ " and " ^ (exp1_to_str r) 
    | Val1 v -> val1_to_str v
	

(* this function generates a pretty printed version of the tree *)
let val1_pretty v =
  match v with
    | True1 -> "val[true]"
    | False1 -> "val[false]"
	
let rec exp1_pretty t =
  match t with
    | Or1 (l,r) -> "exp,or[" ^ (exp1_pretty l) ^ " or " ^ (exp1_pretty r) ^ "]"
    | And1 (l,r) -> "exp,and[" ^ (exp1_pretty l) ^ " and " ^ (exp1_pretty r) ^ "]"
    | Val1 v -> "exp,[" ^ val1_pretty v ^ "]"
	
(* for instance a parse tree for "true or false" can be given as *)
let parsetree0 = Or1(Val1 True1, Val1 False1 ) ;;
exp1_to_str parsetree0 ;; (* = "true or false" *)
exp1_pretty parsetree0 ;; (* = "exp,or[exp,[val[true]] or exp,[val[false]]]" *)

(* a parse tree for "true" can be given as *)
let parsetree1 = Val1 True1 ;;

(* a parse tree for "true and false or true" can be given as *)
let parsetree2 = Or1( And1(Val1 True1, Val1 False1 ), Val1 True1 ) ;;
(* another is *)
let parsetree3 = And1( Val1 True1, Or1(Val1 True1 , Val1 True1) ) ;;

(* a parse tree for "true or true or true" can be given as *)
let parsetree4 = Or1( Or1(Val1 True1, Val1 True1 ), Val1 True1 ) ;;
(* another is *)
let parsetree5 = Or1( Val1 True1, Or1(Val1 True1, Val1 True1  )) ;;

(*
is the grammar ambiguous?
if so give an example string with 2 parse tress and explain how can we can disambiguate the grammar.
*)

(*
parsetree2 and parsetree3 show that the grammar is ambiguous (there is one string generated by 2 grammars)

parsetree4 and parsetree5 alse show that the grammar is ambiguous
*)


(*
write a new grammar that:
 - matches the same strings as the old grammar
 - is unambigous
 - "and" has higher precedence then "or" (most programming languages do this)
*)


(*
apologies to lab 1 where I made a mistake on the whiteboard

intuition: we want to break up all the expressions with "or"s, leaving just the expresions with "and"s

for instance:
____    ____    ______________    _______________________
true or true or true and false or false and true and true

so just focus on the and expressions, perhaps we could try
and_exp ::= <and_exp> and <and_exp> | <val>
val     ::= true | false

but this is ambiguous becuase of the string 
"true and true and true"
which "and" is the root of the parse tree?

this can be fixed by forcing the grammar to associate to the right
and_exp ::= <val> and <and_exp> | <val>
val     ::= true | false
this is unambiguous

now worry about parsing "or"s between the and expressions
or_exp  ::= <or_exp> or <or_exp> | <and_exp>
and_exp ::= <val> and <and_exp> | <val>
val     ::= true | false
again this is ambiguous with the string 
"true or true or true"

this can be fixed again by forcing the grammar to associate to the right
or_exp  ::= <and_exp> or <or_exp> | <and_exp>
and_exp ::= <val> and <and_exp> | <val>
val     ::= true | false
*)


(* the standard parsing architecture looks like
tokenize -> parse tree -> abstract syntax tree
-> evaluation
 *)


(* we can use the above grammar to write part of a parser *)
	
(* write a data type for tokens *)
type token = AndT | OrT | TrueT | FalseT

(* for evaluation we are not intrested in parentisis, we are only intresed in an unambigous tree of opertations
write an ast  *)
type ast = And of ast * ast | Or of ast * ast | Val of bool



let rec valToAst (ls : token list) : (ast * (token list)) option  =
  match ls with
    | TrueT :: rest -> Some (Val true , rest)
    | FalseT :: rest -> Some (Val false , rest)
    | _ -> None
let rec and_expToAst (ls : token list) : (ast * (token list)) option  =
  match valToAst ls with
    | Some ( l,  AndT :: rest ) -> 
	  (match and_expToAst rest with
	    | Some ( r,  rest' ) -> Some (And (l, r),  rest')
		| _ -> None )
    | Some ( l,  rest ) -> Some ( l,  rest )
    | _ -> None
let rec or_expToAst (ls : token list) : (ast * (token list)) option  =
  match and_expToAst ls with
    | Some ( l,  OrT :: rest ) -> 
	  (match or_expToAst rest with
	    | Some ( r,  rest' ) -> Some (Or (l, r),  rest')
		| _ -> None )
    | Some ( l,  rest ) -> Some ( l,  rest )
    | _ -> None


let ex0 = [TrueT ; OrT ; FalseT ; AndT ; FalseT] ;;
or_expToAst ex0 ;;
let ex1 = [TrueT] ;;
let ex2 = [TrueT ; AndT ; FalseT ] ;;
let ex3 = [TrueT ; AndT ; FalseT ; AndT ; FalseT ; AndT ; FalseT ; AndT ; FalseT ] ;;
let ex4 = [TrueT ; OrT ; FalseT ] ;;

(* true or true or true and false or false and true and true *)
let ex5 = [TrueT ; OrT ; TrueT ; OrT ; TrueT ; AndT ; FalseT ; OrT ; FalseT ; AndT ; TrueT ; AndT ; TrueT] ;;



(*
some labs opted to study the harder grammar
exp ::= ( <exp> ) | <exp> or <exp> | <exp> and <exp> | <val>
val ::= true | false
*)


(* some of the strings that this grammar can parse, including all the examples from the prevous grammar *)
"(true or false)";;
"true and (false or true)";;
"(((true))) or (((((true and true)))))";;


(* some strings that this grammar can't parse are *)
"(((true))";;
"(true) (true)";;
"(true and) or (true)";;


(* the parse trees of a grammar can be modeled by data types *)
type val2 = True2 | False2
type exp2 = Paren2 of exp2 | Or2 of (exp2 * exp2) | And2 of (exp2 * exp2) | Val2 of val2

(* these functions generate the string the parse tree represents *)
let val2_to_str v =
  match v with
    | True2 -> "true"
    | False2 -> "false"
	
let rec exp2_to_str t =
  match t with
    | Paren2 e -> "(" ^ (exp2_to_str e) ^ ")"
    | Or2 (l,r) -> (exp2_to_str l) ^ " or " ^ (exp2_to_str r) 
    | And2 (l,r) -> (exp2_to_str l) ^ " and " ^ (exp2_to_str r) 
    | Val2 v -> val2_to_str v
	

(* this function generates a pretty printed version of the tree *)
let val2_pretty v =
  match v with
    | True2 -> "val[true]"
    | False2 -> "val[false]"
	
let rec exp2_pretty t =
  match t with
    | Paren2 e -> "exp,paren[ (" ^ (exp2_to_str e) ^ ") ]"
    | Or2 (l,r) -> "exp,or[" ^ (exp2_pretty l) ^ " or " ^ (exp2_pretty r) ^ "]"
    | And2 (l,r) -> "exp,and[" ^ (exp2_pretty l) ^ " and " ^ (exp2_pretty r) ^ "]"
    | Val2 v -> "exp,[" ^ val2_pretty v ^ "]"

(* some parse trees are *)

(* "(true)" *)
let parsetree6 = Paren2( Val2 True2) ;;
(* "(true or false)" *)
let parsetree7 = Paren2( Or2 (Val2 True2, Val2 False2)) ;;

(* the grammar is ambiguous by the same reasoning as the simpler grammar 

it can be "disambiguated" simiarly to the simpler grammar but with 
or_exp  ::= <and_exp> or <or_exp> | <and_exp>
and_exp ::= <val> and <and_exp> | <val>
val     ::= true | false | ( <or_exp> )
*)


(*
also check out the grammar for sml (a simplified version of ocaml) https://people.mpi-sws.org/~rossberg/sml.html
*)