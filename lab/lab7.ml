(* Simple Robot simulater *)

(* 
this lab we will simulate a very simple robot that moves left and right based on a sequence of instrustions

the robot will operate based off this operational semantics:

(Step :: Right :: rest      , n) -> (rest, n + 1)
(Step :: Left  :: rest      , n) -> (rest, n - 1)
(Jump :: Right :: i :: rest , n) -> (rest, n + i)
(Jump :: Left  :: i :: rest , n) -> (rest, n - i)

*)

(* write a type for instrustions *)

type instruct = Step | Jump | Right | Left | Int of int

(* write a function that simulates the robot given a starting position *)

(* there were 2 approaches, doing the recursion directly or with a helper funciton *)

(* directly *)
let rec runRobot (ls : instruct list) (n: int) : int option =
  match ls with 
    | [] -> Some n
	| Step :: Left  ::          tl ->  runRobot tl (n - 1)
	| Step :: Right ::          tl ->  runRobot tl (n + 1)
	| Jump :: Left  :: Int i :: tl ->  runRobot tl (n - i)
	| Jump :: Right :: Int i :: tl ->  runRobot tl (n + i)
(*	| _ :: tl ->  runRobot tl n *)   (* could have handled failure by skipping instructions, this is a bad way to deal with unexpected input *)
	| _  ->  None                    (* by making the output type an option, we let everyone know not every list of instuctions is valid *)
;;
runRobot [Step; Right ; 
          Step; Right ; 
		  Step; Right ; 
		  Jump ; Left ; Int 3 ;
		  Step; Right ;] 0
;;

(* with a helper function *)
let incRobot (ls : instruct list) (n:int) : (instruct list * int) =
  match ls with
   | Step :: Right          :: rest ->  (rest, n+1)
   | Step :: Left           :: rest ->  (rest, n-1)
   | Jump :: Right :: Int i :: rest ->  (rest, n+i)
   | Jump :: Left  :: Int i :: rest ->  (rest, n-i)
   | [] ->  ([], n)
   | _ ->  ([], n) (* could have handled failure by stoping the robot *)
   
let rec runRobot (ls : instruct list) (n:int) : int =
  let (ls', n') = incRobot ls n
  in match ls' with
       | [] -> n'
	   | _  -> runRobot ls' n'
   
;;

runRobot [Step; Right ; 
          Step; Right ; 
		  Step; Right ; 
		  Jump ; Left ; Int 3 ;
		  Step; Right ;] 0
;;

(* homework hints:
use pattern matching!
when possible, use a data type(s) instead of strings!
pay attention to warnings!
 *)


(* midterm review *)

(* correction:
I said in one lab that "derivations and parse trees are in exact correspondance" this is not tecnically correct.
However,
* every parse tree can be used to gernate a derivation
* every derivation tree can be used to gernate 1 or more parse trees
*)

(*
sample midterm question 21, posted https://piazza.com/class/jzlgrr6vzfy1oq?cid=164 so it could go out before the midterm 
*)

(*
sample midterm question 19,
the grammar generates:

ab (not generated by a*|b* )
b  (not generated by ab* )
aa (not generated by (ab)* )
a
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbb
*)

(*
sample midterm question 23,
ambigous becuase of the sentance
1 and 1 and 1

can be made unabigous with
<exp> ::= <factor> and <exp> | <factor>
<factor> ::= <term> or <factor> | <term> 
<term>::= <bit>|<bool>  | ( <exp> ) 
<bit> ::= 1|0
<bool>::= True | False

or
<exp> ::= <factor> and <exp> | <factor>
<factor> ::= <term> or <factor> | <term> 
<term>::= 1|0|True | False  | ( <exp> ) 
*)


